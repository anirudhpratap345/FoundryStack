from fastapi import FastAPI, HTTPException, BackgroundTasks
from fastapi.responses import FileResponse, JSONResponse
from pydantic import BaseModel
from typing import Dict, List, Optional, Any
import json
import os
import uuid
from datetime import datetime
import asyncio
from pathlib import Path

app = FastAPI(
    title="FoundryStack Exporter Agent",
    description="Exports reviewed blueprints in multiple formats for different use cases",
    version="1.0.0"
)

# Pydantic Models
class ReviewedBlueprint(BaseModel):
    reviewed_founder_report: str
    reviewed_one_pager: str
    reviewed_pitch_ready: str
    reviewed_tweet: str
    issues_found: Optional[List[Dict[str, Any]]] = []
    suggestions: Optional[List[str]] = []
    overall_score: Optional[float] = 0.0
    processing_time: Optional[float] = 0.0
    timestamp: Optional[str] = None

class ExportMetadata(BaseModel):
    user_id: str
    blueprint_name: str
    blueprint_id: Optional[str] = None
    export_formats: Optional[List[str]] = ["json", "markdown", "pdf"]
    include_metadata: Optional[bool] = True
    include_issues: Optional[bool] = True
    include_suggestions: Optional[bool] = True

class ExportRequest(BaseModel):
    reviewed_blueprint: ReviewedBlueprint
    metadata: ExportMetadata

class ExportResponse(BaseModel):
    export_id: str
    files: Dict[str, str]  # format -> file_path
    download_urls: Dict[str, str]  # format -> download_url
    status: str
    message: str
    processing_time: float
    timestamp: str

class ExporterAgent:
    def __init__(self):
        self.export_dir = Path("exports")
        self.export_dir.mkdir(exist_ok=True)
        
        # Create subdirectories for different formats
        (self.export_dir / "json").mkdir(exist_ok=True)
        (self.export_dir / "markdown").mkdir(exist_ok=True)
        (self.export_dir / "pdf").mkdir(exist_ok=True)
        (self.export_dir / "html").mkdir(exist_ok=True)
        
        self.supported_formats = ["json", "markdown", "pdf", "html"]
    
    def generate_export_id(self) -> str:
        """Generate unique export ID"""
        return f"export_{uuid.uuid4().hex[:8]}_{int(datetime.now().timestamp())}"
    
    def sanitize_filename(self, filename: str) -> str:
        """Sanitize filename for safe file system usage"""
        import re
        # Remove or replace invalid characters
        filename = re.sub(r'[<>:"/\\|?*]', '_', filename)
        # Remove multiple underscores and trim
        filename = re.sub(r'_+', '_', filename).strip('_')
        return filename
    
    def export_json(self, reviewed_blueprint: ReviewedBlueprint, metadata: ExportMetadata, export_id: str) -> str:
        """Export blueprint as JSON"""
        try:
            # Prepare JSON data
            json_data = {
                "metadata": {
                    "export_id": export_id,
                    "user_id": metadata.user_id,
                    "blueprint_name": metadata.blueprint_name,
                    "blueprint_id": metadata.blueprint_id,
                    "exported_at": datetime.now().isoformat(),
                    "exporter_version": "1.0.0"
                },
                "blueprint": {
                    "founder_report": reviewed_blueprint.reviewed_founder_report,
                    "one_pager": reviewed_blueprint.reviewed_one_pager,
                    "pitch_ready": reviewed_blueprint.reviewed_pitch_ready,
                    "tweet": reviewed_blueprint.reviewed_tweet
                }
            }
            
            # Add optional metadata
            if metadata.include_issues and reviewed_blueprint.issues_found:
                json_data["review"] = {
                    "issues_found": reviewed_blueprint.issues_found,
                    "suggestions": reviewed_blueprint.suggestions,
                    "overall_score": reviewed_blueprint.overall_score,
                    "processing_time": reviewed_blueprint.processing_time
                }
            
            # Save JSON file
            filename = f"{self.sanitize_filename(metadata.blueprint_name)}_{export_id}.json"
            file_path = self.export_dir / "json" / filename
            
            with open(file_path, 'w', encoding='utf-8') as f:
                json.dump(json_data, f, indent=2, ensure_ascii=False)
            
            return str(file_path)
        except Exception as e:
            raise Exception(f"JSON export failed: {str(e)}")
    
    def export_markdown(self, reviewed_blueprint: ReviewedBlueprint, metadata: ExportMetadata, export_id: str) -> str:
        """Export blueprint as Markdown"""
        try:
            # Prepare Markdown content
            md_content = f"""# {metadata.blueprint_name} - Blueprint

*Generated by FoundryStack AI Pipeline*  
*Export ID: {export_id}*  
*Exported: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}*

---

## 📋 Executive Summary

{reviewed_blueprint.reviewed_one_pager}

---

## 📄 Founder Report

{reviewed_blueprint.reviewed_founder_report}

---

## 🎯 Pitch Deck Summary

{reviewed_blueprint.reviewed_pitch_ready}

---

## 🐦 Social Media

{reviewed_blueprint.reviewed_tweet}

---

## 📊 Review Summary

"""
            
            # Add review information if available
            if metadata.include_issues and reviewed_blueprint.issues_found:
                md_content += f"**Overall Score**: {reviewed_blueprint.overall_score}/100\n\n"
                
                if reviewed_blueprint.issues_found:
                    md_content += "### Issues Found\n\n"
                    for i, issue in enumerate(reviewed_blueprint.issues_found, 1):
                        md_content += f"{i}. **{issue.get('type', 'Unknown').title()}** ({issue.get('severity', 'unknown')}): {issue.get('description', 'N/A')}\n"
                        md_content += f"   - *Suggestion*: {issue.get('suggestion', 'N/A')}\n\n"
                
                if reviewed_blueprint.suggestions:
                    md_content += "### Improvement Suggestions\n\n"
                    for i, suggestion in enumerate(reviewed_blueprint.suggestions, 1):
                        md_content += f"{i}. {suggestion}\n"
            
            md_content += f"""
---

## 📝 Export Information

- **Export ID**: {export_id}
- **User ID**: {metadata.user_id}
- **Blueprint Name**: {metadata.blueprint_name}
- **Exported At**: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
- **Exporter Version**: 1.0.0

---
*This blueprint was generated using FoundryStack's AI-powered multi-agent system.*
"""
            
            # Save Markdown file
            filename = f"{self.sanitize_filename(metadata.blueprint_name)}_{export_id}.md"
            file_path = self.export_dir / "markdown" / filename
            
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(md_content)
            
            return str(file_path)
        except Exception as e:
            raise Exception(f"Markdown export failed: {str(e)}")
    
    def export_html(self, reviewed_blueprint: ReviewedBlueprint, metadata: ExportMetadata, export_id: str) -> str:
        """Export blueprint as HTML"""
        try:
            # Prepare HTML content
            html_content = f"""<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{metadata.blueprint_name} - Blueprint</title>
    <style>
        body {{
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            color: #333;
        }}
        .header {{
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            border-radius: 10px;
            margin-bottom: 30px;
        }}
        .section {{
            margin-bottom: 30px;
            padding: 20px;
            border-left: 4px solid #667eea;
            background: #f8f9fa;
        }}
        .score {{
            display: inline-block;
            padding: 5px 15px;
            border-radius: 20px;
            font-weight: bold;
            color: white;
        }}
        .score.high {{ background: #28a745; }}
        .score.medium {{ background: #ffc107; color: #333; }}
        .score.low {{ background: #dc3545; }}
        .issue {{
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            padding: 15px;
            margin: 10px 0;
            border-radius: 5px;
        }}
        .suggestion {{
            background: #d1ecf1;
            border: 1px solid #bee5eb;
            padding: 15px;
            margin: 10px 0;
            border-radius: 5px;
        }}
        pre {{
            background: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
        }}
        .footer {{
            margin-top: 50px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
            text-align: center;
            color: #666;
        }}
    </style>
</head>
<body>
    <div class="header">
        <h1>{metadata.blueprint_name}</h1>
        <p>AI-Generated Blueprint by FoundryStack</p>
        <p>Export ID: {export_id} | {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</p>
    </div>
    
    <div class="section">
        <h2>📋 Executive Summary</h2>
        <pre>{reviewed_blueprint.reviewed_one_pager}</pre>
    </div>
    
    <div class="section">
        <h2>📄 Founder Report</h2>
        <pre>{reviewed_blueprint.reviewed_founder_report}</pre>
    </div>
    
    <div class="section">
        <h2>🎯 Pitch Deck Summary</h2>
        <pre>{reviewed_blueprint.reviewed_pitch_ready}</pre>
    </div>
    
    <div class="section">
        <h2>🐦 Social Media</h2>
        <pre>{reviewed_blueprint.reviewed_tweet}</pre>
    </div>
"""
            
            # Add review information if available
            if metadata.include_issues and reviewed_blueprint.issues_found:
                html_content += f"""
    <div class="section">
        <h2>📊 Review Summary</h2>
        <p><strong>Overall Score:</strong> <span class="score {'high' if reviewed_blueprint.overall_score >= 80 else 'medium' if reviewed_blueprint.overall_score >= 60 else 'low'}">{reviewed_blueprint.overall_score}/100</span></p>
"""
                
                if reviewed_blueprint.issues_found:
                    html_content += "<h3>Issues Found</h3>"
                    for issue in reviewed_blueprint.issues_found:
                        html_content += f"""
                        <div class="issue">
                            <strong>{issue.get('type', 'Unknown').title()}</strong> ({issue.get('severity', 'unknown')})<br>
                            {issue.get('description', 'N/A')}<br>
                            <em>Suggestion: {issue.get('suggestion', 'N/A')}</em>
                        </div>
                        """
                
                if reviewed_blueprint.suggestions:
                    html_content += "<h3>Improvement Suggestions</h3>"
                    for suggestion in reviewed_blueprint.suggestions:
                        html_content += f'<div class="suggestion">{suggestion}</div>'
            
            html_content += f"""
    </div>
    
    <div class="footer">
        <p>Generated by FoundryStack AI Pipeline</p>
        <p>Export ID: {export_id} | User: {metadata.user_id}</p>
        <p>Exported: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</p>
    </div>
</body>
</html>
"""
            
            # Save HTML file
            filename = f"{self.sanitize_filename(metadata.blueprint_name)}_{export_id}.html"
            file_path = self.export_dir / "html" / filename
            
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(html_content)
            
            return str(file_path)
        except Exception as e:
            raise Exception(f"HTML export failed: {str(e)}")
    
    def export_pdf(self, reviewed_blueprint: ReviewedBlueprint, metadata: ExportMetadata, export_id: str) -> str:
        """Export blueprint as PDF (placeholder implementation)"""
        try:
            # For now, create a placeholder PDF file
            # In production, you would use libraries like WeasyPrint, ReportLab, or wkhtmltopdf
            filename = f"{self.sanitize_filename(metadata.blueprint_name)}_{export_id}.pdf"
            file_path = self.export_dir / "pdf" / filename
            
            # Create a simple text-based PDF placeholder
            pdf_content = f"""%PDF-1.4
1 0 obj
<<
/Type /Catalog
/Pages 2 0 R
>>
endobj

2 0 obj
<<
/Type /Pages
/Kids [3 0 R]
/Count 1
>>
endobj

3 0 obj
<<
/Type /Page
/Parent 2 0 R
/MediaBox [0 0 612 792]
/Contents 4 0 R
>>
endobj

4 0 obj
<<
/Length 200
>>
stream
BT
/F1 12 Tf
100 700 Td
({metadata.blueprint_name} - Blueprint) Tj
0 -20 Td
(Generated by FoundryStack AI Pipeline) Tj
0 -20 Td
(Export ID: {export_id}) Tj
0 -20 Td
(Exported: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}) Tj
ET
endstream
endobj

xref
0 5
0000000000 65535 f 
0000000009 00000 n 
0000000058 00000 n 
0000000115 00000 n 
0000000204 00000 n 
trailer
<<
/Size 5
/Root 1 0 R
>>
startxref
454
%%EOF
"""
            
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(pdf_content)
            
            return str(file_path)
        except Exception as e:
            raise Exception(f"PDF export failed: {str(e)}")
    
    async def export_blueprint(self, request: ExportRequest) -> ExportResponse:
        """Export blueprint in multiple formats"""
        start_time = datetime.now()
        export_id = self.generate_export_id()
        
        try:
            files = {}
            download_urls = {}
            
            # Determine which formats to export
            formats_to_export = request.metadata.export_formats or ["json", "markdown"]
            
            # Export in each requested format
            for format_type in formats_to_export:
                if format_type not in self.supported_formats:
                    continue
                
                if format_type == "json":
                    file_path = self.export_json(request.reviewed_blueprint, request.metadata, export_id)
                elif format_type == "markdown":
                    file_path = self.export_markdown(request.reviewed_blueprint, request.metadata, export_id)
                elif format_type == "html":
                    file_path = self.export_html(request.reviewed_blueprint, request.metadata, export_id)
                elif format_type == "pdf":
                    file_path = self.export_pdf(request.reviewed_blueprint, request.metadata, export_id)
                else:
                    continue
                
                files[format_type] = file_path
                download_urls[format_type] = f"/download/{format_type}/{export_id}"
            
            processing_time = (datetime.now() - start_time).total_seconds()
            
            return ExportResponse(
                export_id=export_id,
                files=files,
                download_urls=download_urls,
                status="success",
                message=f"Blueprint exported successfully in {len(files)} format(s)",
                processing_time=processing_time,
                timestamp=datetime.now().isoformat()
            )
            
        except Exception as e:
            processing_time = (datetime.now() - start_time).total_seconds()
            return ExportResponse(
                export_id=export_id,
                files={},
                download_urls={},
                status="error",
                message=f"Export failed: {str(e)}",
                processing_time=processing_time,
                timestamp=datetime.now().isoformat()
            )

# Initialize Exporter Agent
exporter_agent = ExporterAgent()

@app.get("/health")
async def health_check():
    """Health check endpoint"""
    return {
        "status": "healthy",
        "timestamp": datetime.now().isoformat(),
        "supported_formats": exporter_agent.supported_formats,
        "export_directory": str(exporter_agent.export_dir)
    }

@app.post("/export", response_model=ExportResponse)
async def export_blueprint(request: ExportRequest):
    """Export blueprint in multiple formats"""
    try:
        response = await exporter_agent.export_blueprint(request)
        return response
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Export failed: {str(e)}")

@app.post("/export/simple")
async def export_simple_blueprint(reviewed_blueprint: dict, metadata: dict):
    """Simple endpoint for quick blueprint export"""
    try:
        # Convert dict to Pydantic models
        reviewed_blueprint_obj = ReviewedBlueprint(**reviewed_blueprint)
        metadata_obj = ExportMetadata(**metadata)
        request = ExportRequest(reviewed_blueprint=reviewed_blueprint_obj, metadata=metadata_obj)
        
        response = await exporter_agent.export_blueprint(request)
        return response
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Export failed: {str(e)}")

@app.get("/download/{format_type}/{export_id}")
async def download_file(format_type: str, export_id: str):
    """Download exported file"""
    try:
        # Find the file in the appropriate directory
        format_dir = exporter_agent.export_dir / format_type
        if not format_dir.exists():
            raise HTTPException(status_code=404, detail="Format directory not found")
        
        # Find file with matching export_id
        files = list(format_dir.glob(f"*_{export_id}.*"))
        if not files:
            raise HTTPException(status_code=404, detail="File not found")
        
        file_path = files[0]
        if not file_path.exists():
            raise HTTPException(status_code=404, detail="File not found")
        
        return FileResponse(
            path=str(file_path),
            filename=file_path.name,
            media_type='application/octet-stream'
        )
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Download failed: {str(e)}")

@app.get("/exports")
async def list_exports():
    """List all available exports"""
    try:
        exports = []
        for format_dir in exporter_agent.export_dir.iterdir():
            if format_dir.is_dir():
                for file_path in format_dir.iterdir():
                    if file_path.is_file():
                        exports.append({
                            "format": format_dir.name,
                            "filename": file_path.name,
                            "size": file_path.stat().st_size,
                            "created": datetime.fromtimestamp(file_path.stat().st_ctime).isoformat()
                        })
        
        return {
            "exports": exports,
            "total": len(exports),
            "timestamp": datetime.now().isoformat()
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to list exports: {str(e)}")

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8005)
